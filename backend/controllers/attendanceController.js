// Copy this ENTIRE file to: controllers/attendanceController.js

const { Attendance, BiometricPunch, Employee, ShiftType, Company, HolidayList, Holiday, Department } = require('../models');
const { Op } = require('sequelize');
const moment = require('moment');

// ==========================================
// HELPER FUNCTIONS
// ==========================================

// Calculate time difference in minutes
const getMinutesDifference = (time1, time2) => {
    const date1 = new Date(`2000-01-01 ${time1}`);
    const date2 = new Date(`2000-01-01 ${time2}`);
    return Math.abs((date2 - date1) / 1000 / 60);
};

// Calculate working hours between two timestamps
const calculateWorkingHours = (checkIn, checkOut) => {
    if (!checkIn || !checkOut) return 0;
    const diff = new Date(checkOut) - new Date(checkIn);
    return parseFloat((diff / 1000 / 60 / 60).toFixed(2));
};

// Check if date is a holiday
const checkIfHoliday = async (date, holidayListId) => {
    if (!holidayListId) return false;
    
    const holiday = await Holiday.findOne({
        where: {
            holidayListId,
            holidayDate: date,
            status: 'Active'
        }
    });
    
    return !!holiday;
};

// Process a single employee's attendance for a date
const processEmployeeAttendance = async (employee, attendanceDate) => {
    const { id: employeeId, shiftType, companyId } = employee;
    
    // Check if it's a holiday
    const isHoliday = await checkIfHoliday(
        attendanceDate, 
        shiftType.holidayListId
    );

    // Get all biometric punches for this employee on this date
    const punches = await BiometricPunch.findAll({
        where: {
            employeeId,
            punchDate: attendanceDate,
            status: 'Valid'
        },
        order: [['punchTime', 'ASC']]
    });

    // Separate IN and OUT punches
    const checkIns = punches.filter(p => p.punchType === 'IN');
    const checkOuts = punches.filter(p => p.punchType === 'OUT');

    const firstCheckIn = checkIns.length > 0 ? checkIns[0].punchTime : null;
    const lastCheckOut = checkOuts.length > 0 ? checkOuts[checkOuts.length - 1].punchTime : null;

    // Initialize attendance data
    const attendanceData = {
        employeeId,
        shiftTypeId: shiftType.id,
        attendanceDate,
        scheduledStartTime: shiftType.startTime,
        scheduledEndTime: shiftType.endTime,
        firstCheckIn,
        lastCheckOut,
        totalCheckIns: checkIns.length,
        totalCheckOuts: checkOuts.length,
        companyId,
        autoGenerated: true,
        isHoliday,
        isWeekOff: false,
        workingHours: 0,
        breakHours: 0,
        overtimeHours: 0,
        isLate: false,
        lateByMinutes: 0,
        isEarlyExit: false,
        earlyExitMinutes: 0,
        remarks: null
    };

    // If it's a holiday and auto-attendance is enabled
    if (isHoliday && shiftType.markAutoAttendanceOnHolidays) {
        attendanceData.status = 'Holiday';
        attendanceData.remarks = 'Auto-marked as holiday';
        return attendanceData;
    }

    // If no check-in found
    if (!firstCheckIn) {
        attendanceData.status = 'Absent';
        attendanceData.remarks = shiftType.autoMarkAbsentIfNoCheckIn 
            ? 'Auto-marked absent - No check-in found'
            : 'No check-in recorded';
        return attendanceData;
    }

    // Calculate working hours
    let workingHours = 0;
    
    if (shiftType.workingHoursCalculation === 'first_to_last') {
        workingHours = calculateWorkingHours(firstCheckIn, lastCheckOut);
    } else if (shiftType.workingHoursCalculation === 'fixed_hours') {
        const shiftDuration = getMinutesDifference(
            shiftType.startTime, 
            shiftType.endTime
        ) / 60;
        workingHours = shiftDuration;
    } else if (shiftType.workingHoursCalculation === 'with_breaks') {
        const minPairs = Math.min(checkIns.length, checkOuts.length);
        for (let i = 0; i < minPairs; i++) {
            const pairDuration = calculateWorkingHours(
                checkIns[i].punchTime, 
                checkOuts[i].punchTime
            );
            workingHours += pairDuration;
        }
    }

    attendanceData.workingHours = parseFloat(workingHours.toFixed(2));

    // Determine attendance status based on working hours
    if (workingHours < shiftType.halfDayHours) {
        attendanceData.status = 'Absent';
    } else if (workingHours >= shiftType.halfDayHours && workingHours < shiftType.absentHours) {
        attendanceData.status = 'Half Day';
    } else {
        attendanceData.status = 'Present';
    }

    // Check for late arrival
    if (shiftType.enableLateEntry && firstCheckIn) {
        const scheduledStart = moment(`${attendanceDate} ${shiftType.startTime}`);
        const actualCheckIn = moment(firstCheckIn);
        const lateMinutes = actualCheckIn.diff(scheduledStart, 'minutes');
        
        if (lateMinutes > shiftType.lateGracePeriod) {
            attendanceData.isLate = true;
            attendanceData.lateByMinutes = lateMinutes - shiftType.lateGracePeriod;
            if (attendanceData.status === 'Present') {
                attendanceData.status = 'Late';
            }
        }
    }

    // Check for early exit
    if (shiftType.enableEarlyExit && lastCheckOut) {
        const scheduledEnd = moment(`${attendanceDate} ${shiftType.endTime}`);
        const actualCheckOut = moment(lastCheckOut);
        const earlyMinutes = scheduledEnd.diff(actualCheckOut, 'minutes');
        
        if (earlyMinutes > shiftType.earlyExitPeriod) {
            attendanceData.isEarlyExit = true;
            attendanceData.earlyExitMinutes = earlyMinutes;
        }
    }

    // Calculate overtime
    const shiftDuration = getMinutesDifference(
        shiftType.startTime, 
        shiftType.endTime
    ) / 60;
    
    if (workingHours > shiftDuration) {
        attendanceData.overtimeHours = parseFloat(
            (workingHours - shiftDuration).toFixed(2)
        );
    }

    return attendanceData;
};

// ==========================================
// CONTROLLER FUNCTIONS
// ==========================================

// @desc    Generate attendance for a specific date range
// @route   POST /api/attendance/generate
// @access  Private
exports.generateAttendance = async (req, res) => {
    const { companyId, startDate, endDate, employeeIds } = req.body;

    if (!companyId || !startDate || !endDate) {
        return res.status(400).json({ 
            success: false,
            message: 'Company ID, start date, and end date are required' 
        });
    }

    try {
        const start = moment(startDate).format('YYYY-MM-DD');
        const end = moment(endDate).format('YYYY-MM-DD');
        
        const results = {
            processed: 0,
            created: 0,
            updated: 0,
            errors: []
        };

        // Get all employees for the company
        const whereClause = { companyId, status: 'Active' };
        if (employeeIds && employeeIds.length > 0) {
            whereClause.id = { [Op.in]: employeeIds };
        }

        const employees = await Employee.findAll({
            where: whereClause,
            include: [
                {
                    model: ShiftType,
                    as: 'shiftType',
                    include: [
                        {
                            model: HolidayList,
                            as: 'holidayList',
                            required: false
                        }
                    ]
                }
            ]
        });

        console.log(`ðŸ“Š Found ${employees.length} employees to process`);

        // Generate attendance for each employee for each date in range
        const currentDate = moment(start);
        const endMoment = moment(end);

        while (currentDate.isSameOrBefore(endMoment)) {
            const dateStr = currentDate.format('YYYY-MM-DD');

            for (const employee of employees) {
                try {
                    results.processed++;
                    
                    if (!employee.shiftType) {
                        results.errors.push({
                            employeeId: employee.id,
                            employeeName: `${employee.firstName} ${employee.lastName}`,
                            date: dateStr,
                            error: 'No shift assigned to employee'
                        });
                        continue;
                    }

                    const attendanceData = await processEmployeeAttendance(employee, dateStr);
                    
                    // Check if attendance already exists
                    const existingAttendance = await Attendance.findOne({
                        where: {
                            employeeId: employee.id,
                            attendanceDate: dateStr
                        }
                    });

                    if (existingAttendance) {
                        await existingAttendance.update(attendanceData);
                        results.updated++;
                    } else {
                        await Attendance.create(attendanceData);
                        results.created++;
                    }
                } catch (error) {
                    results.errors.push({
                        employeeId: employee.id,
                        employeeName: `${employee.firstName} ${employee.lastName}`,
                        date: dateStr,
                        error: error.message
                    });
                }
            }

            currentDate.add(1, 'day');
        }

        console.log('âœ… Generation complete:', results);

        res.status(200).json({
            success: true,
            message: 'Attendance generation completed',
            results
        });
    } catch (error) {
        console.error('âŒ Error generating attendance:', error);
        res.status(500).json({ 
            success: false,
            message: 'Server Error', 
            error: error.message 
        });
    }
};

// @desc    Get attendance records
// @route   GET /api/attendance
// @access  Private
exports.getAttendance = async (req, res) => {
    const { companyId, startDate, endDate, employeeId, status, page = 1, limit = 50 } = req.query;

    if (!companyId) {
        return res.status(400).json({ 
            success: false,
            message: 'Company ID is required' 
        });
    }

    try {
        const whereClause = { companyId };

        if (startDate && endDate) {
            const startMoment = moment(startDate, 'YYYY-MM-DD', true);
    const endMoment = moment(endDate, 'YYYY-MM-DD', true);
    
    if (!startMoment.isValid() || !endMoment.isValid()) {
        return res.status(400).json({ 
            success: false,
            message: 'Invalid date format. Use YYYY-MM-DD',
            received: { startDate, endDate }
        });
    }
    
    whereClause.attendanceDate = {
        [Op.between]: [
            startMoment.format('YYYY-MM-DD'),
            endMoment.format('YYYY-MM-DD')
        ]
    };
        } else if (startDate) {
            whereClause.attendanceDate = { 
                [Op.gte]: moment(startDate).format('YYYY-MM-DD')
            };
        } else if (endDate) {
            whereClause.attendanceDate = { 
                [Op.lte]: moment(endDate).format('YYYY-MM-DD')
            };
        }

        if (employeeId) whereClause.employeeId = employeeId;
        if (status) whereClause.status = status;

        const offset = (parseInt(page) - 1) * parseInt(limit);

        const { count, rows: attendance } = await Attendance.findAndCountAll({
            where: whereClause,
            include: [
                {
                    model: Employee,
                    as: 'employee',
                    attributes: ['id', 'firstName', 'lastName', 'employeeCode'],
                    include: [
                        {
                            model: Department,
                            as: 'department',
                            attributes: ['name']
                        }
                    ]
                },
                {
                    model: ShiftType,
                    as: 'shiftType',
                    attributes: ['id', 'name', 'startTime', 'endTime']
                }
            ],
            order: [['attendanceDate', 'DESC'], ['id', 'DESC']],
            limit: parseInt(limit),
            offset: offset
        });

        res.status(200).json({
            success: true,
            data: attendance,
            pagination: {
                total: count,
                page: parseInt(page),
                limit: parseInt(limit),
                pages: Math.ceil(count / parseInt(limit))
            }
        });
    } catch (error) {
        console.error('Error fetching attendance:', error);
        res.status(500).json({ 
            success: false,
            message: 'Server Error', 
            error: error.message 
        });
    }
};

// @desc    Get attendance by ID
// @route   GET /api/attendance/:id
// @access  Private
exports.getAttendanceById = async (req, res) => {
    const { id } = req.params;

    try {
        const attendance = await Attendance.findByPk(id, {
            include: [
                {
                    model: Employee,
                    as: 'employee'
                },
                {
                    model: ShiftType,
                    as: 'shiftType'
                }
            ]
        });

        if (!attendance) {
            return res.status(404).json({ 
                success: false,
                message: 'Attendance record not found' 
            });
        }

        res.status(200).json({
            success: true,
            data: attendance
        });
    } catch (error) {
        console.error('Error fetching attendance:', error);
        res.status(500).json({ 
            success: false,
            message: 'Server Error', 
            error: error.message 
        });
    }
};

// @desc    Update attendance record
// @route   PUT /api/attendance/:id
// @access  Private
exports.updateAttendance = async (req, res) => {
    const { id } = req.params;

    try {
        const attendance = await Attendance.findByPk(id);

        if (!attendance) {
            return res.status(404).json({ 
                success: false,
                message: 'Attendance record not found' 
            });
        }

        await attendance.update(req.body);

        const updated = await Attendance.findByPk(id, {
            include: [
                {
                    model: Employee,
                    as: 'employee',
                    attributes: ['id', 'firstName', 'lastName', 'employeeCode']
                },
                {
                    model: ShiftType,
                    as: 'shiftType',
                    attributes: ['id', 'name', 'startTime', 'endTime']
                }
            ]
        });

        res.status(200).json({
            success: true,
            message: 'Attendance updated successfully',
            data: updated
        });
    } catch (error) {
        console.error('Error updating attendance:', error);
        res.status(400).json({ 
            success: false,
            message: 'Server Error', 
            error: error.message 
        });
    }
};

// @desc    Delete attendance record
// @route   DELETE /api/attendance/:id
// @access  Private
exports.deleteAttendance = async (req, res) => {
    const { id } = req.params;

    try {
        const attendance = await Attendance.findByPk(id);

        if (!attendance) {
            return res.status(404).json({ 
                success: false,
                message: 'Attendance record not found' 
            });
        }

        await attendance.destroy();
        res.status(200).json({ 
            success: true,
            message: 'Attendance record deleted successfully' 
        });
    } catch (error) {
        console.error('Error deleting attendance:', error);
        res.status(500).json({ 
            success: false,
            message: 'Server Error', 
            error: error.message 
        });
    }
};

// @desc    Get attendance summary/statistics
// @route   GET /api/attendance/summary
// @access  Private
exports.getAttendanceSummary = async (req, res) => {
    const { companyId, startDate, endDate, employeeId } = req.query;

    if (!companyId) {
        return res.status(400).json({ 
            success: false,
            message: 'Company ID is required' 
        });
    }

    try {
        const whereClause = { companyId };

        if (startDate && endDate) {
            whereClause.attendanceDate = {
                [Op.between]: [
                    moment(startDate).format('YYYY-MM-DD'),
                    moment(endDate).format('YYYY-MM-DD')
                ]
            };
        }

        if (employeeId) {
            whereClause.employeeId = employeeId;
        }

        const attendance = await Attendance.findAll({
            where: whereClause,
            attributes: ['status', 'workingHours', 'overtimeHours', 'isLate', 'isEarlyExit']
        });

        const summary = {
            totalDays: attendance.length,
            present: attendance.filter(a => a.status === 'Present').length,
            absent: attendance.filter(a => a.status === 'Absent').length,
            halfDay: attendance.filter(a => a.status === 'Half Day').length,
            late: attendance.filter(a => a.isLate).length,
            earlyExit: attendance.filter(a => a.isEarlyExit).length,
            holiday: attendance.filter(a => a.status === 'Holiday').length,
            weekOff: attendance.filter(a => a.status === 'Week Off').length,
            totalWorkingHours: attendance.reduce((sum, a) => sum + (parseFloat(a.workingHours) || 0), 0).toFixed(2),
            totalOvertimeHours: attendance.reduce((sum, a) => sum + (parseFloat(a.overtimeHours) || 0), 0).toFixed(2),
        };

        res.status(200).json({
            success: true,
            data: summary
        });
    } catch (error) {
        console.error('Error fetching attendance summary:', error);
        res.status(500).json({ 
            success: false,
            message: 'Server Error', 
            error: error.message 
        });
    }
};

// @desc    Approve attendance
// @route   PATCH /api/attendance/:id/approve
// @access  Private
exports.approveAttendance = async (req, res) => {
    const { id } = req.params;
    const { userId } = req.body;

    try {
        const attendance = await Attendance.findByPk(id);

        if (!attendance) {
            return res.status(404).json({ 
                success: false,
                message: 'Attendance record not found' 
            });
        }

        await attendance.update({
            approvedBy: userId,
            approvedAt: new Date()
        });

        res.status(200).json({
            success: true,
            message: 'Attendance approved successfully',
            data: attendance
        });
    } catch (error) {
        console.error('Error approving attendance:', error);
        res.status(500).json({ 
            success: false,
            message: 'Server Error', 
            error: error.message 
        });
    }
};

module.exports = exports;